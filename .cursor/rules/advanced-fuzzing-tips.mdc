---
description: 
globs: 
alwaysApply: true
---
# Advanced Fuzzing Tips - AI Agent Guide

## Quick Navigation

Choose your task:
- **[Creating Target Functions](mdc:#target-functions)** → Handler patterns, clamping, disabling
- **[Setting Up Test Suite](mdc:#setup-best-practices)** → Deployment, story management, state exploration
- **[Tracking State Changes](mdc:#ghost-variables)** → Before/after state tracking
- **[Inlined Properties](mdc:#inlined-properties)** → Function-specific assertions
- **[Finding Precision Issues](mdc:#rounding-errors)** → Division/precision loss detection

## Target Functions

### Basic Handler Pattern
```solidity
// Target contract
contract Counter {
    uint256 public number;
    function increment() public { number++; }
}

// Handler in TargetFunctions.sol
abstract contract TargetFunctions {
    function counter_increment() public asActor {
        counter.increment();
    }
}
```

### Actor Management

**Use `asActor` for general functions:**
```solidity
function counter_increment() public asActor {
    counter.increment();
}
```

**Use `asAdmin` for privileged functions:**
```solidity
function yield_resetYield() public asAdmin {
    yield.resetYield();
}
```

### Clamping Strategy

**Pattern: Always provide both clamped and unclamped versions**

```solidity
// ✅ Unclamped handler (explores full space)
function counter_setNumber(uint256 newNumber) public asActor {
    counter.setNumber(newNumber);
    
    // Inlined property check
    if (newNumber != 0) {
        t(counter.number() == newNumber, "number != newNumber");
    }
}

// ✅ Clamped handler (calls unclamped with restricted inputs)
function counter_setNumber_clamped(uint256 newNumber) public asActor {
    newNumber = between(newNumber, 1, type(uint256).max);
    counter_setNumber(newNumber); // Call unclamped version
}
```

### Disabling Functions

**When to disable:**
- Functions that don't explore interesting states
- Admin functions causing too many false positives
- Functions that always revert in your setup

**How to disable:**
```solidity
// Option 1: Comment out
// function problematic_function() public asActor {
//     target.problematicFunction();
// }

// Option 2: Use alwaysRevert modifier
function problematic_function() public alwaysRevert {
    target.problematicFunction();
}
```

## Setup Best Practices

### ✅ Do's

| Practice | Why | Example |
|----------|-----|---------|
| **Create own setup** | Avoid existing test biases | `setup() { counter = new Counter(); }` |
| **Keep story clean** | One operation per handler | Separate `deposit()` and `withdraw()` handlers |
| **Mock complex contracts** | Simplify fuzzing | Mock oracles instead of full implementation |
| **Add donation handlers** | Explore edge states | Direct token transfers to contracts |

### ❌ Don'ts

| Avoid | Why | Better Approach |
|-------|-----|----------------|
| **Reusing existing tests** | Inherits biases | Write minimal setup from scratch |
| **Multiple operations per handler** | Hard to debug | One state change per handler |
| **Complex periphery contracts** | Slows fuzzing | Mock or simplify |

### Story Management

**❌ Bad: Multiple operations make debugging hard**
```solidity
function vault_deposit_and_redeem(uint256 assets) public asActor {
    uint256 sharesReceived = vault.deposit(assets);
    vault.redeem(sharesReceived);
}
```

**✅ Good: Separate handlers for clear story**
```solidity
function vault_deposit(uint256 assets) public asActor {
    vault.deposit(assets, _getActor());
}

function vault_redeem(uint256 shares) public asActor {
    vault.redeem(shares, _getActor(), _getActor());
}
```

### Programmatic Deployment Pattern

**Static deployment (limited):**
```solidity
function setup() internal {
    token = new MockERC20("Test", "TEST", 18); // Fixed 18 decimals
}
```

**✅ Programmatic deployment (comprehensive):**
```solidity
// In TargetFunctions.sol
function deploy_new_token(uint8 decimals) public {
    decimals = uint8(between(decimals, 6, 24));
    _newAsset(decimals);
}

function switch_active_token(uint256 index) public {
    _switchAsset(index);
}

// Use current token in other handlers
function token_transfer(uint256 amount) public asActor {
    IERC20 currentToken = _getAsset();
    currentToken.transfer(_getActor(), amount);
}
```

## Ghost Variables

### Basic Setup Pattern

**1. Define variables in BeforeAfter.sol:**
```solidity
struct Vars {
    uint256 totalSupply;
    uint256 userBalance;
    uint256 pricePerShare;
}

Vars internal _before;
Vars internal _after;
```

**2. Update ghost variables:**
```solidity
function __before() internal {
    _before.totalSupply = token.totalSupply();
    _before.userBalance = token.balanceOf(_getActor());
}

function __after() internal {
    _after.totalSupply = token.totalSupply();
    _after.userBalance = token.balanceOf(_getActor());
}
```

**❌ Don't: use in inlined handlers because `_after()` is only called after handler execution completes**
```solidity
function token_transfer(uint256 amount) public updateGhosts asActor {
    token.transfer(_getActor(), amount);
    
    // Use ghost variables in properties
    eq(_before.totalSupply, _after.totalSupply, "totalSupply changed");
}
```

**✅ Do: Use in global properties:**
```solidity
    function property_number_never_zero() public {
        eq(_after.totalSupply, _before.totalSupply, "totalSupply shouldn't change");
    }
```

### ⚠️ Critical Ghost Variable Rules

| ❌ Never Do | ✅ Always Do |
|-------------|--------------|
| Put assertions in `__before()` or `__after()` | Only read state values |
| Complex computations that might revert | Simple state reads |
| Operations that can fail | Safe, guaranteed operations |

**❌ Bad: Can revert and break fuzzing**
```solidity
function __before() internal {
    // This can underflow and revert!
    _before.difference = _before.balance - token.balanceOf(user);
}
```

**✅ Good: Safe state reading**
```solidity
function __before() internal {
    _before.balance = token.balanceOf(user);
    _before.totalSupply = token.totalSupply();
}
```

### Operation Type Tracking

**Setup operation types:**
```solidity
enum OpType { GENERIC, ADD, REMOVE }
OpType internal currentOperation;

modifier updateGhostsWithType(OpType op) {
    currentOperation = op;
    __before();
    _;
    __after();
}
```

**Use in handlers:**
```solidity
function vault_deposit(uint256 assets) public updateGhostsWithType(OpType.ADD) asActor {
    vault.deposit(assets, _getActor());
}

function vault_withdraw(uint256 assets) public updateGhostsWithType(OpType.REMOVE) asActor {
    vault.withdraw(assets, _getActor(), _getActor());
}
```

**Use in properties:**
```solidity
function property_price_per_share_on_removal() public {
    if (currentOperation == OpType.REMOVE) {
        lte(_after.pricePerShare, _before.pricePerShare, "price increased on removal");
    }
}
```

## Inlined Properties

### Basic Pattern
```solidity
function counter_setNumber(uint256 newNumber) public updateGhosts asActor {
    try counter.setNumber(newNumber) {
        // Property: number should equal input if input != 0
        if (newNumber != 0) {
            t(counter.number() == newNumber, "number != newNumber");
        }
    } catch {
        // Handle expected reverts
        t(false, "setNumber should not revert");
    }
}
```

### ❌ Avoid Duplication

**Don't repeat same property in multiple handlers:**
```solidity
// ❌ Bad: Same property in multiple places
function deposit_handler1() public {
    // ... deposit logic ...
    t(vault.totalSupply() >= sumBalances, "invariant violated");
}

function deposit_handler2() public {
    // ... different deposit logic ...
    t(vault.totalSupply() >= sumBalances, "invariant violated"); // Duplicated!
}
```

**✅ Use global property instead with OpType as a precondition:**
```solidity
// In Properties.sol
function property_total_supply_invariant() public {
    if(currentOperation == DEPOSIT) {
        t(vault.totalSupply() >= sumBalances, "invariant violated");
    }
}
```

### Stateless Pattern

**For testing without permanent state changes:**
```solidity
modifier stateless() {
    _;
    revert("stateless"); // Revert after execution
}

function doomsday_complex_scenario() public stateless {
    // Perform multiple operations to test scenario
    vault.deposit(1000);
    vault.withdraw(500);
    
    // Test property
    t(someComplexProperty(), "property failed");
    
    // State reverts after this function
}
```

## Rounding Errors

### Detection Strategy

**1. Start with exact checks:**
```solidity
function vault_withdraw(uint256 assets) public {
    uint256 sharesBefore = vault.balanceOf(_getActor());
    uint256 expectedShares = vault.previewWithdraw(assets);
    
    vault.withdraw(assets, _getActor(), _getActor());
    
    uint256 sharesAfter = vault.balanceOf(_getActor());
    uint256 actualSharesBurned = sharesBefore - sharesAfter;
    
    // Exact check - will fail if rounding occurs
    eq(actualSharesBurned, expectedShares, "shares burned != expected");
}
```

**2. Allow fuzzer to find violations:**
```bash
echidna . --contract CryticTester --config echidna.yaml
```

**3. Create optimization test for worst case:**
```solidity
// For Echidna optimization mode
function echidna_maximize_rounding_error() public returns (uint256) {
    // Return the rounding error amount
    return expectedShares > actualSharesBurned ? 
           expectedShares - actualSharesBurned : 
           actualSharesBurned - expectedShares;
}
```

### Precision Loss Patterns

**Common scenarios to test:**
- Division operations: `amount / rate`
- Percentage calculations: `(amount * fee) / 10000`
- Conversions between different decimal places
- Compound operations: multiple divisions in sequence

## Quick Reference

### Essential Modifiers
- `asActor` - Execute as random actor
- `asAdmin` - Execute as admin
- `updateGhosts` - Track before/after state
- `updateGhostsWithType(OpType)` - Track state with operation type
- `stateless` - Revert state after execution
- `alwaysRevert` - Disable handler

### Assertion Functions
- `t(bool, string)` - General assertion
- `eq(a, b, string)` - Equality check
- `lte/gte(a, b, string)` - Comparison checks
- `between(value, min, max)` - Clamp values

### File Structure
- `Setup.sol` - Contract deployment
- `TargetFunctions.sol` - Handler functions
- `Properties.sol` - Global invariants
- `BeforeAfter.sol` - Ghost variable tracking

This guide provides actionable patterns for implementing advanced fuzzing techniques in the Chimera framework.
